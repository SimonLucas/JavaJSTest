<!DOCTYPE html><html><head>    <meta http-equiv="content-type" content="text/html; charset=utf-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>XKG Article</title>    <script src="https://distill.pub/template.v1.js"></script>    <script src="./bundle.js"></script>    <script type="text/javascript" src="./kotlin.js"></script>    <link rel="stylesheet" href="chessboard.css">    <script type="text/javascript" src="jquery-3.5.1.js"></script>    <script type="text/javascript" src="chessboard.js"></script>    <script type="text/front-matter">  title: "A Simple Intro to Evolutionary Algorithms"  description: "The key elements of an evolutionary algorithm, demonstrating  their generality and ease of application"  authors:  - Simon Lucas: https://github.com/SimonLucas/  - Alexander Dockhorn: https://adockhorn.github.io/  affiliations:  - Queen Mary University of London: https://www.qmul.ac.uk/  - Queen Mary University of London: https://www.qmul.ac.uk/    </script>    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>    <script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">    </script>    <script type="text/javascript" src="./JavaJSTest.js"></script>    <style>        .high { background:yellow; }        .test {            text-align: center;            color: red;            }    </style></head><!-- <script type="text/javascript" src="./jquery.js"></script> --><body><dt-article>    <h1>A Simple Intro to Evolutionary Algorithms</h1>    <h4>The key elements of evolutionary algorithms, demonstrating their        generality and ease of application</h4>    <dt-byline>Byline goes here, but I can't see it on the page...</dt-byline>    <p align="center">        <canvas id="mazeCanvas" width="450" height="225" style="border:5px solid #009999;">        </canvas>    </p>    <div align="center">        <dt-caption>Application of the simple EA described            below to evolve mazes. <em>n</em> shows the number of fitness            evaluations made. The fitness function aims for the longest            shortest-path distance between top left and bottom-right of grid. The            beauty of an EA is that we can keep all other things equal and just            changing the fitness function enables many different problems to be            solved. <em>TO-DO: Add controls</em></dt-caption>    </div>    <p></p>    <script>       //new JavaJSTest.sample.XAppLauncher("mazeCanvas", "EvoMaze", 100).run();    </script>    <h4 id="randString">Rand String Here</h4>    <script>        function randSeq() {            var place = document.getElementById("randString");            var util = new JavaJSTest.evo.EvoUtil();            console.log(util);            console.log(util.randSeq())            place.innerHTML = util.randSeq();            console.log(util.randBin())            console.log(util.randBin(20))        }    </script>    <p>        <button onclick="randSeq()">Random Binary String</button>    </p>    <h3>Contents</h3>    <p></p>    <ul id="toc">    </ul>    <p></p>    <script language="JavaScript">        window.addEventListener('load', function() {            console.log('All assets are loaded here');            // this loop iteration works fine            var tocItems = document.getElementsByTagName("H2");            var toc = document.getElementById("toc");            console.log("nToCEntries: " + tocItems.length);            var i;            for (i = 0; i < tocItems.length; i++) {                var item = tocItems[i];                item.style.backgroundColor = "#EEEEEE";                var entry = document.createElement("li");                var link = document.createElement("a");                // console.log(item.innerHTML);                console.log(item.innerText);                link.innerText = item.innerText;                link.href = "#" + item.innerText;                item.id = item.innerText;                entry.appendChild(link);                toc.appendChild(entry);            }        })    </script>    <script src="./toc.js"></script>    <h2>Introduction</h2>    <p> Natural evolution underlies the amazing diversity and complexity of        life on earth. This has led researchers since the dawn of computer        science and AI to try to capture the essence of these natural processes        in evolutionary algorithms (EA). While EAs have been the subject of much        research for more than six decades, the essential parts of an EA are        surprisingly simple and powerful. Even the most basic versions provide a        useful and often competitive benchmark across a range of problems. </p>    <p>        <canvas id="caveCanvas" width="500" height="350" style="border:5px solid #009999;">        </canvas>    </p>    <figcaption>Cave Swing Game, Played by Evolving Action Plans in Real Time.        <em>TO-DO: Add controls and offer human player mode.</em></figcaption>    <p></p>    <script>       //new JavaJSTest.sample.XAppLauncher("caveCanvas", "CaveSwing", 20).run();    </script>    <p> The aim of this short article is to explain and demonstrate the key        elements of an EA via a set of interactive elements embedded in this        page. As you read through the article you can play with these to better        understand them. The key elements are: </p>    <ul>        <li>Initialisation</li>        <li>Copying and Variation</li>        <li>Evaluation</li>        <li>Selection</li>    </ul>    <h2>Initialisation</h2>    <p> At the beginning of solving any problem using an EA, we require a starting population.        A population consists of a set of candidate solutions which are also known as individuals.        An individual encodes the solution that can be applied to your problem, and therefore,        largely depends on the problem at hand.x        Lets consider the seemingly simple puzzle of placing eight chess queens on an 8x8 chessboard so        that no two queens threaten each other. Thus, no two queens share the same row, column or diagonal.        Do you think you are up to the task? Go ahead and try it yourself:    </p>    <div>        <div id="board-letsplay" style="width: 320px; margin: auto auto"></div>    </div>    <script type="module" src="./chessboard/chessboard_lets_play.js"></script>    <p>        Given this problem statement we can find various ways of encoding a solution.        Lets first use a simple binary matrix in which each 1 encodes a queen and each 0 encodes an empty field.        Try this encoding by clicking on either the cells of the matrix on the left or any field on the chessboard        to remove or add a queen at the clicked position.    </p>    <div>        <div style="overflow: hidden; width:600px; margin: auto auto">            <div id="board-for-matrix-representation" style="width: 280px; float: left; margin: auto auto"></div>            <div id="board-matrix-representation" class="matrix" style="width: 280px; float: right; margin: auto auto; margin-right:10px; margin-bottom: 10px"></div>            <script type="module" src="./chessboard/chessboard_matrix_representation.js"></script>        </div>    </div>    <p>        Now this encoding can encode a valid solution, but it also covers a lot of unnecessary candidates.        Lets summarize what we know about the problem and the requirements of its solution to come up with a better encoding.    </p>    <ul>        <li>the solution consists of exactly 8 queens</li>        <li>each row can include only one queen, otherwise they would threaten each other</li>        <li>each column can include only one queen, otherwise they would threaten each other</li>    </ul>    <p>        Since each column can contain only a single queen, we can condense our matrix representation into a vector.        We will make use of a row vector, in which each element encodes the row in which the queen of the same index will be placed.        See below some examples for queen and vector representations.    </p>    <div>        <div style="overflow: hidden; margin: auto auto; width: fit-content">            <div style="width: 180px; float:left; margin-left:5px">                <div id="board-vector-example-1" style="width: 160px; margin-bottom:5px"></div>                <div id="board-vector-1" class="matrixsmall" style="width: 152px; margin-bottom:5px; margin-left:2px"></div>            </div>            <div style="width: 180px; float:left" >                <div id="board-vector-example-2" style="width: 160px; margin-bottom:5px"></div>                <div id="board-vector-2" class="matrixsmall" style="width: 152px; margin-bottom:5px; margin-left:2px"></div>            </div>            <div style="width: 180px; float:left; margin-right:5px">                <div id="board-vector-example-3" style="width: 160px; margin-bottom:5px"></div>                <div id="board-vector-3" class="matrixsmall" style="width: 152px; margin-bottom:5px; margin-left:2px"></div>            </div>        </div>    </div>    <script type="module" src="./chessboard/chessboard_vector_representation.js"></script>    <h2>Mutation</h2>    <p>        Mutation is the first evolutionary operator to modify individuals of our population.        Given the vector notation introduced above, we want to modify a randomized change for creating        a new individual from an existing one. Click on a any element of the vector to randomly        change the position of the encoded queen.    </p>    <div>        <div style="overflow: hidden; margin: auto auto; width: fit-content">            <div style="width: 180px; float:left; margin-left:5px">                <div id="board-vector-mutation-1" style="width: 160px; margin-bottom:5px"></div>                <div id="vector-mutation-1" class="matrixsmall" style="width: 152px; margin-bottom:5px; margin-left:2px"></div>            </div>            <div style="width: 180px; float:left" >                <div id="board-vector-mutation-2" style="width: 160px; margin-bottom:5px"></div>                <div id="vector-mutation-2" class="matrixsmall" style="width: 152px; margin-bottom:5px; margin-left:2px"></div>            </div>            <div style="width: 180px; float:left; margin-right:5px">                <div id="board-vector-mutation-3" style="width: 160px; margin-bottom:5px"></div>                <div id="vector-mutation-3" class="matrixsmall" style="width: 152px; margin-bottom:5px; margin-left:2px"></div>            </div>        </div>    </div>    <script type="module" src="./chessboard/chessboard_vector_mutation.js"></script>    <h2>Crossover</h2>    <p>        Crossover combines the information of two vectors.    </p>    <div>        <div style="overflow: hidden; margin: auto auto; width: fit-content">            <div style="width: fit-content; float:left; margin-left:5px">                <div id="board-vector-crossover-1" style="width: 160px; margin-bottom:5px"></div>                <div id="vector-crossover-1" class="matrixsmall" style="width: 152px; margin-bottom:5px; margin-left:2px"></div>            </div>            <div style="width: fit-content; float:left" >                <div id="board-vector-crossover-2" style="width: 160px; margin-bottom:5px"></div>                <div id="vector-crossover-2" class="matrixsmall" style="width: 152px; margin-bottom:5px; margin-left:2px"></div>            </div>        </div>        <div style="width: fit-content; margin: auto auto">            <div style="overflow: hidden;  margin-top: 20px; margin-left: 5px; margin-right:5px">                <div id="vector-crossover-1b" class="matrixsmall" style="width: 152px; margin-bottom:5px; margin-left:2px"></div>                <div id="vector-crossover-2b" class="matrixsmall" style="width: 152px; margin-bottom:5px; margin-left:2px"></div>            </div>        </div>        <div style="overflow: hidden; margin: auto auto; width: fit-content; margin-top:20px">            <div style="width:fit-content; float:left; margin-right:5px; margin-left:5px">                <div id="vector-crossover-3" class="matrixsmall" style="width: 152px; margin-bottom:5px; margin-left:2px; margin-right: 2px"></div>                <div id="board-vector-crossover-3" style="width: 160px; margin-bottom:5px"></div>            </div>        </div>    </div>    <script type="module" src="./chessboard/chessboard_vector_crossover.js"></script>    <h2>Copying and Variation</h2>    <p> A simple and effective type of variation operator is mutation. There        are many types of mutation operator, but here we're going to use a very        simple one. This will consider each element of an individual in turn,        randomly changing each one with a specified probability, which you'll        get to choose. In other words, we'll run along the vector of bits,        flipping each one on the toss of a biased coin. </p>    <h2>Evaluation</h2>    <p> An evaluation method is required in order to inform the decision of        which individual(s) to select for "breeding". There are three types of        evaluation commonly used, plus a fourth that's kind of exciting but I        suggest rarely used. </p>    <ul>        <li>Absolute</li>        <li>Relative</li>        <li>Interactive</li>        <li>In the wild</li>    </ul>    <p><em>Absolute</em> involves an objective measurement of an individual        such as speed, weight or height. The measurement will in no way depend        on other individuals in the population. However, the selection process        will still make comparisons with other individuals, but this does not        affect the measurements. </p>    <p><em>Relative</em> is when each measurement is an outcome of an        interaction between at least two individuals in the population. For        example, we can evaluate the fitness of a set of chess playing        algorithms by playing them against each other and measuring the points        (wins and draws) each one obtains. The relative method has the great        benefit of enabling the open-ended evolution of systems with        ever-increasing intelligence. </p>    <p><em>Interactive</em> uses a human to select the best individual(s) at        each iteration of the algorithm. This can be labour-intensive but        sometimes leads to very interesting results that would be difficult to        obtain by other means.</p>    <p><em>In the wild</em> is where the evolved solutions compete for        survival in some real-world process: financial trading being an obvious        possibility. Here, evolved algorithmic traders operate in real-world        financial markets, with survival being dependent on their ability to        prosper. Like the relative method, this can also lead to ever-increasing        intelligence, where algrorithms can obtain a competitive advantage by        processing more data streams (news, social media, financial tick data)        in cleverer ways. It's not clear whether this is used much in practice,        at least in its purest form, but has been the subject of some        interesting fiction including        <dt-cite key="FearIndex">The Fear Index</dt-cite>.    </p>    <p> Of course in a very broad sense many aspects of product design have        strong evolutionary aspects where the best traits make it through into        future products (think phones, cars), but there are many other factors        involved also. </p>    <h2>Selection</h2>    <p> Having evaluated the individuals in our population, we then select        which ones to copy and vary for our next generation. In the interests of        keeping it simple, we're going to select the best each time (also called        elitist selection), with the subtle twist of preferring the newer one if        two candidates have equal fitness. This avoids getting stuck in areas of        the search space where the fitness landscape is flat. </p>    <h2>Evolution</h2>    <p>Have covered the essentials, we're now ready to evolve stuff!</p>    <p class="high">Add some actual Kotlin code for the main loop of the EA</p>    <h2>Experiment</h2>    <p class="high"> Add in a canvas to display some visual stuff to evolve.        Add controls to adjust algorithm parameters and the target fitness function</p>    <p id="testPara" class="high">        Elements go here: they should be form elements, but currently just adding an H2 each time        with a number in it.    </p>    <script>        function createForm() {          console.log("Calling FormCreateTest()");          new JavaJSTest.sample.FormCreateTest();          console.log("Called FormCreateTest()");        }    </script>    <p>        <button id="addText" onclick="createForm()">Add elements above:</button>    </p></dt-article><dt-appendix>    <h2>Appendix: Additional Info</h2></dt-appendix><script type="text/bibliography">@book{FearIndex,  author = {Harris, Robert},  title = {The Fear Index},  year = {2011},  publisher={Hutchinson},  url = {https://en.wikipedia.org/wiki/The_Fear_Index}}@INPROCEEDINGS{LucasXKGDemo,  author = {Simon M. Lucas},  title = {Cross Platform Games in Kotlin},  booktitle = {Proceedings of IEEE Conference on Games},  pages = {774--775},  year = {2020},}</script></body></html>